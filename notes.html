<h1 id="implementing-content-addressed-code-for-c">IMPLEMENTING CONTENT-ADDRESSED CODE FOR C</h1>
<p>thing to think about next: what is that second map?
hashes to code?
do we download the code?
store it in a big db?
when do we do this? compile time? run time? when we say My_tool RUN <file> ?</p>
<p>Big idea with these maps: the state of your code text file has nothing to do with the state of the codebase data structure. You can have functions in/missing from your text file regardless of whether the functions are in/missing the codebase (stuff you commit).</p>
<h1 id="map-1">Map 1</h1>
<p>Map 1: Names --&gt; AST fragment hashes</p>
<ul>
<li>key: a function name</li>
<li>value: a hash of the AST representation of a function</li>
</ul>
<h2 id="notes">Notes</h2>
<ol>
<li><p>This map is a cache that is never invalidated. That is, entries are never removed unless the user says so.</p>
</li>
<li><p>Two funcs/types with the same name cannot exist. That is, you can&#39;t have</p>
</li>
</ol>
<pre><code>X = abc
X = def
</code></pre>
<p>in your code</p>
<p>IDEA: The value should actually have some metadata in it, like the function name. Issue with this: refactoring would have to go into the values, not just the keys. So, TODO: look into Unison&#39;s internal codebase data structures, and see how Unison does it.</p>
<h2 id="operations">Operations</h2>
<p>TODO: flesh these out</p>
<ol>
<li>User writes an entirely new function</li>
</ol>
<p>Make a new entry in the 
The name of the function</p>
<ol start="2">
<li><p>User deletes a function</p>
</li>
<li><p>User modifies the contents of an existing function</p>
</li>
<li><p>User modifies the name of an existing function</p>
</li>
<li><p>User modifies the contents AND name of an existing function</p>
</li>
</ol>
<h1 id="map-2">Map 2</h1>
<p>Map 2: AST fragment hashes --&gt; AST fragments</p>
<ul>
<li>key: The hash of the AST representation of a function</li>
<li>value: The AST representation of that function</li>
</ul>
<p>ISSUE: how to handle dependencies in the value of this map? Meaning, when is just the AST repr of a function not enough to execute that function?</p>
<p>Potential Soln: Do I need to annotate the AST to maintain a list of dependencies?</p>
<h1 id="important-considerations">Important Considerations</h1>
<h2 id="external-libraries">External Libraries</h2>
<p>I&#39;m going to need to index this / populate the massive code database with all the standard library stuff.</p>
<p>For example, if a function uses a standard library function, we need to hunt down the code of that function (and its dependencies recursively)</p>
<h2 id="recursion">Recursion</h2>
<p>What if function a calls function b, and function b calls function a?</p>
<h2 id="user-defined-types">User-Defined Types</h2>
<p>This discussion so far has been only about functions. But I also want to extend this idea to user-defined typedefs, structs/unions, and enums. Is it even possible to implement this for functions without implementing this for types?</p>
<h2 id="constants-and-globals">Constants and Globals</h2>
<p>Similar to above (&quot;user defined types&quot;), do we also need to implement this idea for global constants / globals? Say a function depends on a global... how do we handle that?</p>
<h2 id="macros">Macros</h2>
<p>Same thing as above with macros -- <code>#define MACRO</code>, but even worse. This is because C macros are textual/preprocessor. So you can&#39;t &quot;link&quot; a macro like you can link an object file: the actual text <code>&quot;#define MACRO&quot;</code> needs to be in the file, and even worse, with the right visibility.</p>
<p>Solution: wait, is this even an issue? I should just run the preprocessor first, then do all the Unison indexing stuff! So it actually shouldn&#39;t be an issue!</p>
<h2 id="missing-deleted-function-dependences">Missing (Deleted) Function Dependences</h2>
<p>Say function A calls function B, and you store both these functions in the &quot;codebase&quot;. In Unison, deleting function B in your code, doesn&#39;t do anything. It doesn&#39;t &quot;commit&quot; that delete to the codebase. Therefore, function A can still run just fine, with no issues.</p>
<p>You can only delete a function F by manually saying &quot;delete F&quot; in <code>ucm</code>. But, the delete will only be successful when all dependences of F (all functions that call F) are also deleted.</p>
<h3 id="this-idea-in-c">This idea in C</h3>
<p>Same setup as above: Func A calls Func B, and you delete func B (in your code textfile). The deleted function (B) still needs to be linked in the final compiled executable... or else you get linker errors like &quot;cannot find function B&quot;. </p>
<p>So, when building an executable, look at the main function, find all its dependences, and for each dependence, compile it into its own object file. Then link all the obj files together.</p>
<p>But what if there is no main function? What if we want to compile a library, or into a .so perhaps? To be considered further....</p>
<h3 id="modifying-dependences">Modifying Dependences</h3>
<p>If A calls B, and you modify B, but you don&#39;t modify A, which version of B will A use?</p>
<p>This relates to the overall question of which version of a function does the caller use? The most-recently-committed version? Or the most recent version at the time of the caller&#39;s indexing? (surely the latter...). My thinking of why the latter is because the hash of the dependence is serialized into the caller&#39;s AST, which is in turn serialized. This is because <code>lookup()</code> happens at compile time, not run time (right? I am assuming this because I can&#39;t see it working efficiently any other way...).</p>
<h3 id="does-lookup-happen-at-compile-or-run-time">Does lookup happen at compile or run time?</h3>
<p>If it happened at run time: could be very slow to &quot;fetch&quot; the dependence if it doesn&#39;t have it already.</p>
<h1 id="unison-first-impressions">Unison First Impressions</h1>
<p>Upon installation, Unison created a dir in my home dir to &quot;store the codebase&quot;. This is where the append-only cache is stored, as a massive sqlite DB.</p>
<p>When initializing a new project, Unison &quot;fetched&quot; the standard library, and I assume it &quot;stored&quot; it in the codebase. Because in order for Unison to work, EVERYTHINGGG (including the standard library and all dependencies) must be indexed in the codebase, just like it were any other user-supplied code.</p>
<p>I have to manually say &quot;add&quot; to commit new files to this local repository</p>
<h1 id="resources">Resources</h1>
<ul>
<li><a href="https://www.unison-lang.org/docs/the-big-idea">https://www.unison-lang.org/docs/the-big-idea</a></li>
<li><a href="https://www.unison.cloud/our-approach/">https://www.unison.cloud/our-approach/</a></li>
<li><a href="https://www.unison-lang.org/articles/distributed-datasets/">https://www.unison-lang.org/articles/distributed-datasets/</a></li>
<li><a href="https://www.youtube.com/watch?v=gCWtkvDQ2ZI">https://www.youtube.com/watch?v=gCWtkvDQ2ZI</a></li>
</ul>

